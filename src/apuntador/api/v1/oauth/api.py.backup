"""
OAuth 2.0 endpoints for Google Drive and Dropbox.

Handles authorization, callback, token exchange, token refresh, and token revocation
for multiple OAuth providers.
"""

from fastapi import APIRouter, HTTPException, Query
from fastapi.responses import RedirectResponse

from apuntador.core.logging import logger
from apuntador.di import SettingsDep, get_oauth_service
from apuntador.models import (
    ErrorResponse,
    OAuthAuthorizeRequest,
    OAuthAuthorizeResponse,
    OAuthRefreshRequest,
    OAuthRevokeRequest,
    OAuthRevokeResponse,
    OAuthTokenRequest,
    OAuthTokenResponse,
)
from apuntador.utils.pkce import generate_code_challenge
from apuntador.utils.security import generate_state, sign_data, verify_signed_data

router = APIRouter(prefix="/api/oauth", tags=["OAuth"])


@router.post(
    "/authorize/{provider}",
    response_model=OAuthAuthorizeResponse,
    responses={
        400: {"model": ErrorResponse},
        500: {"model": ErrorResponse},
    },
)
async def authorize(
    provider: str,
    request: OAuthAuthorizeRequest,
    settings: SettingsDep,
) -> OAuthAuthorizeResponse:
    """
    Starts the OAuth authorization flow.

    Generates the OAuth provider's authorization URL with PKCE.

    Args:
        provider: OAuth provider (googledrive, dropbox)
        request: Request data (code_verifier, redirect_uri, state)
        settings: Application configuration

    Returns:
        Authorization URL and signed state
    """
    logger.info(f"Starting OAuth authorization flow for provider: {provider}")
    logger.debug(
        f"Request details: redirect_uri={request.redirect_uri}, code_verifier={request.code_verifier[:20]}..., state={request.state}"
    )

    try:
        service = get_oauth_service(
            provider, settings, redirect_uri=request.redirect_uri
        )

        logger.debug(f"Service created: {service.__class__.__name__}")
        logger.debug(
            f"Service config: client_id={service.client_id}, redirect_uri={service.redirect_uri}"
        )

        # Generate code challenge from code verifier
        code_challenge = generate_code_challenge(request.code_verifier)
        logger.debug(
            f"Generated code_challenge for {provider}: {code_challenge[:20]}..."
        )

        # Generate state if not provided
        state = request.state or generate_state()
        logger.debug(f"Using state: {state[:8]}... (truncated)")

        # Sign state with code_verifier to verify later
        signed_state = sign_data(
            {
                "state": state,
                "code_verifier": request.code_verifier,
                "provider": provider,
                "redirect_uri": request.redirect_uri,  # Store redirect_uri in signed state
            }
        )

        # Generate authorization URL
        auth_url = service.get_authorization_url(
            code_challenge=code_challenge,
            state=signed_state,
        )

        logger.info(f"âœ… Authorization URL generated successfully for {provider}")
        logger.info(f"ðŸ”— FULL AUTHORIZATION URL: {auth_url}")
        logger.debug(f"URL length: {len(auth_url)} characters")

        return OAuthAuthorizeResponse(
            authorization_url=auth_url,
            state=signed_state,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error in OAuth authorization for {provider}: {e}")
        raise HTTPException(status_code=500, detail=str(e)) from e


@router.get("/callback/{provider}")
async def oauth_callback(
    provider: str,
    code: str = Query(..., description="Authorization code"),
    state: str = Query(..., description="State parameter"),
    settings: SettingsDep = None,
) -> RedirectResponse:
    """
    OAuth callback called by the provider.

    This endpoint receives the authorization code and redirects to the client
    with the necessary parameters to complete the flow.

    Args:
        provider: OAuth provider
        code: Authorization code
        state: Signed state
        settings: Configuration

    Returns:
        Redirect to client with code and state
    """
    logger.info(f"ðŸ“¥ OAuth callback received for provider: {provider}")
    logger.debug(f"Code: {code[:20]}...")
    logger.debug(f"State: {state[:50]}...")

    try:
        # Verify signed state
        state_data = verify_signed_data(state)

        if not state_data:
            logger.warning(f"Invalid state received in OAuth callback for {provider}")
            # Redirect with error if state is invalid (fallback to apuntador scheme)
            return RedirectResponse(
                url=f"apuntador://oauth-callback?error=invalid_state&provider={provider}"
            )

        if state_data.get("provider") != provider:
            logger.warning(
                f"Provider mismatch in OAuth callback. "
                f"Expected: {provider}, Got: {state_data.get('provider')}"
            )
            redirect_uri = state_data.get("redirect_uri", "apuntador://oauth-callback")
            return RedirectResponse(
                url=f"{redirect_uri}?error=provider_mismatch&provider={provider}"
            )

        # Extract redirect_uri from signed state
        redirect_uri = state_data.get("redirect_uri", "apuntador://oauth-callback")
        logger.info(f"âœ… State verified, redirecting to: {redirect_uri}")

        # Construct deep link with code and state
        redirect_url = f"{redirect_uri}?code={code}&state={state}&provider={provider}"

        logger.info(f"ðŸ”— Redirecting to app: {redirect_url}")

        return RedirectResponse(url=redirect_url, status_code=302)

    except Exception as e:
        logger.error(f"âŒ Error processing OAuth callback: {e}")
        # On error, try to redirect with error
        error_url = f"apuntador://oauth-callback?error=callback_failed&error_description={str(e)}"
        return RedirectResponse(url=error_url, status_code=302)


@router.post(
    "/token/{provider}",
    response_model=OAuthTokenResponse,
    responses={
        400: {"model": ErrorResponse},
        500: {"model": ErrorResponse},
    },
)
async def exchange_token(
    provider: str,
    request: OAuthTokenRequest,
    settings: SettingsDep,
) -> OAuthTokenResponse:
    """
    Exchanges authorization code for access token.

    Args:
        provider: OAuth provider
        request: Code and code_verifier
        settings: Configuration

    Returns:
        Access token and refresh token
    """
    logger.info(f"Exchanging authorization code for token with provider: {provider}")

    try:
        redirect_uri = None

        # Verify state if provided
        if request.state:
            logger.debug("Verifying state parameter")
            state_data = verify_signed_data(request.state)
            if not state_data:
                logger.warning("Invalid state parameter in token exchange")
                raise HTTPException(status_code=400, detail="Invalid state")

            # Verify code_verifier matches
            if state_data.get("code_verifier") != request.code_verifier:
                logger.warning("Code verifier mismatch in token exchange")
                raise HTTPException(status_code=400, detail="Code verifier mismatch")

            # Extract redirect_uri from state
            redirect_uri = state_data.get("redirect_uri")
            logger.debug(f"Using redirect_uri from state: {redirect_uri}")

        service = get_oauth_service(provider, settings, redirect_uri=redirect_uri)

        # Exchange code for tokens
        logger.debug(f"Calling provider {provider} to exchange code for token")
        token_data = await service.exchange_code_for_token(
            code=request.code,
            code_verifier=request.code_verifier,
        )

        logger.info(f"Successfully exchanged code for token with {provider}")

        return OAuthTokenResponse(
            access_token=token_data["access_token"],
            refresh_token=token_data.get("refresh_token"),
            expires_in=token_data.get("expires_in", 3600),
            token_type=token_data.get("token_type", "Bearer"),
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error exchanging code for token with {provider}: {e}")
        raise HTTPException(status_code=500, detail=str(e)) from e


@router.post(
    "/refresh/{provider}",
    response_model=OAuthTokenResponse,
    responses={
        400: {"model": ErrorResponse},
        500: {"model": ErrorResponse},
    },
)
async def refresh_token(
    provider: str,
    request: OAuthRefreshRequest,
    settings: SettingsDep,
) -> OAuthTokenResponse:
    """
    Refreshes access token using refresh token.

    Args:
        provider: OAuth provider
        request: Refresh token
        settings: Configuration

    Returns:
        New access token
    """
    logger.info(f"Refreshing access token with provider: {provider}")

    try:
        service = get_oauth_service(provider, settings)

        token_data = await service.refresh_access_token(
            refresh_token=request.refresh_token,
        )

        logger.info(f"Successfully refreshed token with {provider}")

        return OAuthTokenResponse(
            access_token=token_data["access_token"],
            refresh_token=token_data.get("refresh_token"),
            expires_in=token_data.get("expires_in", 3600),
            token_type=token_data.get("token_type", "Bearer"),
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error refreshing token with {provider}: {e}")
        raise HTTPException(status_code=500, detail=str(e)) from e


@router.post(
    "/revoke/{provider}",
    response_model=OAuthRevokeResponse,
    responses={
        400: {"model": ErrorResponse},
        500: {"model": ErrorResponse},
    },
)
async def revoke_token(
    provider: str,
    request: OAuthRevokeRequest,
    settings: SettingsDep,
) -> OAuthRevokeResponse:
    """
    Revokes an access token.

    Args:
        provider: OAuth provider
        request: Token to revoke
        settings: Configuration

    Returns:
        Revocation result
    """
    logger.info(f"Revoking token with provider: {provider}")

    try:
        service = get_oauth_service(provider, settings)

        success = await service.revoke_token(token=request.token)

        logger.info(
            f"Token revocation {'successful' if success else 'failed'} with {provider}"
        )

        return OAuthRevokeResponse(
            success=success,
            message=(
                "Token revoked successfully" if success else "Failed to revoke token"
            ),
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error revoking token with {provider}: {e}")
        raise HTTPException(status_code=500, detail=str(e)) from e
